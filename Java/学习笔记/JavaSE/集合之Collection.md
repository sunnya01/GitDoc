#### 集合

##### Collection

###### List

保存有序的可重复的数据，数组的可扩容版替代常用的存储数据的集合

Vector 类似于AarraysList，但是是线程安全的性能较低

ArrayList底层使用Object[]数据保存数据,对于静态的生成添加或者查询是适用,非线程安全相对Vector性能较高,ArrayList查询效率比LinkedList高 

LinkedList底层使用双向链表存储,

即A - B - C,某一区间段内的第二个元素B包含了一个指向第1个元素A的地址以保证能在内存空间中可以寻找到唯一的上级存储地点位置，

同时B还保存了下一级的C的地址以保证可以向下寻址到下级元素地点，

使用链式存储的好处是不需要再向数组那样为了保证有序性需要让数据在内存中占用连续的内存空间，而每次在特定位置删除或者新增都需要将节点后面的所有内存数据都移动的弊端，

当在LinkedList中如果需要新增节点D在A和B之间时只需要在内存中新开辟一个区域保存这个数据，并将A的下级地址值给到D的下级地址值，A的下级地址值替换为D的地址值。B的上级地址值给到D的上级地址值，B的上级地址值替换为D的地址值即可完成插入操作。删除同理

###### Set

保存无序的不可重复的数据

HashSet 无序性体现在他的存储的数据结构，HashSet的存储采用的是一个动态长度的数据，每个数组的元素都独立作为一个链式存储结构的头部。

当往HashSet添加一个值时，

会通过一个*f(x)*计算出他需要保存在数据的角标(x = 这个实例对象的hashCode方法返回值,*f(?)*表示一段通过hashCode计算角标的代码逻辑如果计算得到的角标超出当前数组则对数组进行扩容)，

当作为头部信息保存的数组当前角标下不存在数据则直接保存，

如果已经存在数据，则进行哈希值比对，如果相同则保存失败，

如果不同则将当前数组角标的对象(这个对象会保存HashSet数据元素以及一个链式地址保存的属性)的下级对象的地址填充为当前需要插入的对象地址,

这种通过哈希值比对的算法形式执行效率远大于每次新增对象时需要遍历比较已存在对象从而实现唯一性的算法

LinkedHashSet 是基于HashSet数据结构新增了与LinkedList相同的上级节点下级节点的地址属性，这样当遍历时,LinkedHashSet可以根据一定的条件进行顺序遍历

TreeSet 是与HashSet并列的一种数据存储结构，这里面的Tree主要体现的是数据保存时是按照红黑二叉树结构(一种根节点的左子节点是小于它右子节点大于它的二分法树状结构)保存的意思，不是传统意义的树状结构存储子叶节点,他依然采用链式存储，

但是相比于线性的链式存储，他使用一种二叉树的结构存储。链式存储每次取数都要根据开始节点记录的前后关系遍历数据才能读到，

红黑二叉树的数据存储结构有一下特点1.不重复2.强制要求有比较器从而保证存入链式结构的数据是有序的(数据链接先后顺序的有序而不是数组那种按照整块内存区域的紧凑排列的有序)3.红黑二叉树的根节点会根据整个树状结构更换保证根节点到所有的子节点的路径不会出现太大的差距。

举例: 1,2,3,4,5,3000,6000,按照传统的二分法进行分的话，数据存入的时候可能存在3000作为根节点，然后{1,2,3,4,5}都排列在根节点左边,{6000}处于根节点右边。这样的树状结构就是严格按照中间值存储的不平衡的树状结构(极限情况下可能出现某个子节点举例根节点路径特别长的情况,这样会导致读取这一子节点时需要遍历的对象变多)

红黑二叉树的特点就是根据左右节点数量进行动态调整根节点元素。这样可以保证读取任意子节点时具有相同的时间复杂度,能够更好的保证数据读取的效率

##### 静态内部类

在 Java 中，静态内部类是一种特殊的嵌套类，它使用 static 关键字修饰，具有独特的特性和使用场景

静态内部类不依赖于外部类的实例，可以直接创建和使用

###### LinkedList

**private static class** Node<E> {
    E **item**;
    Node<E> **next**;
    Node<E> **prev**;

​    Node(Node<E> prev, E element, Node<E> next) {
​        **this**.**item** = element;
​        **this**.**next** = next;
​        **this**.**prev** = prev;
​    }
}