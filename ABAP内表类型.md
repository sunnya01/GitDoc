ABAP内表类型

HashedTable

主要用户数据量特别大，还需要一直维护数据的情况，且每一份数据实例数据量较大

例如。处理接口日志，数据量很大，然后重处理的时候还需要像内部维护数据

这种情况就适合如下处理

将日志表的guid作为哈希表的主键，然后把其他信息例如请求参数，报文内容等全都一起存入哈希表

然后对外只提供guid以及一些少量信息作为排序表展示

这样用户查看接口日志报表的时候，可以对guid+少量字段也就是key组成的的标准内表进行操作

当具体查看某一行内容的时候，使用guid去哈希表进行哈希查询，这样既保证了用户前台查看流畅

又可以快速查看日志记录的具体内容

哈希表的优势就是不论数据量大小，插入的效率都是一样的，按照key读取的速率也是一样的

但是他是无序的，因此作为 展示用途不合适，并且哈希表的数据在完整的循环输出效率是低于标准表的

那辅助哈希键也是一样的道理，如果我定义了一个标准表，但是我希望可以按照某种唯一的key去快速查询到对应的记录

这里都是类似java中map的概念，也就是key作为一个查询条件，而我们最终的目标是对应的表行的其他信息并且该信息数据量

往往远高于key的数据量，因此我们会给标准表添加一个辅助的hashed key，这样做可以在读取时快速的通过key查找到对应的记录

但是辅助键需要耗费额外的内存空间去维护哈希索引

性能评比

sorted    insert       0.001695  0.010681  0.015731

hashed  insert        0.000062  0.000089  0.000087

stand    append      0.000044



举例: 1. 纯哈希表使用场景,适合在服务端持久化运行的服务，将数据存储在内存中的哈希表中，减少数据库访问频率

但是SAP每次执行程序都是新的独立的线程，因此很少会有大批量数据读取以后保存在哈希表中，并且还需要向里面维护数据的场景

举例: 2. 排序表 + 次级哈希键,适用大部分场景，排序表+唯一或者非唯一排序键可以让数据读取范围读取效率变高，数据写入的时候

可能会有点慢，但是SAP程序大部分都是一个用户对一个进程因此并发较低可以忽略。相反排序表可以强制要求内部数据是有序的

这样条件循环遍历或者按照排序键读取都可以有较快的速度，而且不需要像标准表一样重复排序。外置唯一的哈希键可以保证表内数据

被处理完以后，允许用户通过哈希键实现效率更稳定的读取(为什么还需要挂一个哈希键？因为虽然排序表也可以继续挂次级排序键但是如果需要实现唯一性则排序键的字段过多性能消耗较大，使用哈希键的次级键可以降低性能消耗 )

举例3:  根据以上结论，标准表如果需要额外扩展排序功能或者哈希功能，可以再添加以上次级键





如果一份数据只需要按照键值查询，或者插入，或者修改，则应该使用哈希表，比如接口日志，它只有一个guid作为唯一性主键

整个alv输出的内容映射到保存完整的数据的哈希表中，重处理的时候插入效率也很高，并且不会随着日志数量上升而导致效率变低。

同时可以给该哈希表外挂一个辅助排序键，方便循环的时候可以根据辅助键的要求进行查询或者输出(哈希表的内表依然可以排序)

如果一份数据只需要按照键值查询，但是不能保证唯一性，则使用排序表

如果一份数据是哪来按照一定要求输出计算组成其他数据的，也选择排序表 使用非唯一键作为排序要求，这样进行其他操作的时候不再

需要重复排序，或者插入少量数据以后也不会导致顺序发生变化。并且比sort+binary稳定。如果同时还需要根据表内的唯一性主键进行访问，还可以外挂一个哈希辅助键，提高访问效率。

辅助键: 任何表都可以外挂辅助键，辅助键的效果如上所述，可以挂多层辅助键(索引)，但是消耗性能较高。辅助键的加载不会发生在定义和数据插入时，而是使用懒加载，也可以使用类CL*UTILS工具类进行主动加载(通过这个查看索引加载的时间消耗)。

VALUE #( FOR struc IN itab ( struc ) ),这里的(struc) 表示整个value表达式返回的是个内表，而每个内表的数据是(struc)表达式写入的，因为写入行和FOR语句没有必然联系，但是触发的次数是一致的

Using Key，在Loop中 filter中 delete中 insert lines中都可以使用该关键字，主要作用表现在执行逻辑处理时能够参照该键值索引进行处理，这里如果使用的是primary key则表现出的效果与内表看到的一致，如果使用辅助键则具体根据辅助键定义的内容一致

缺点: 无法进行模糊判断。通常只能根据主键的字段进行 = 判断 和 and连接。因此如果需要模糊判断通常还是不要使用Using Key，本质上还是循环了整个内表的数据。

常用的新语法，

新语法通常直接使用(  )进行语法简略

result =  keyword ?(  ).

? 位置在所有新语法都是一个意思那就是最终返回结果的结构类型，#表示类型推断

VALUE 替代原来的赋值和创建操作例如原来的append 或者 =

REDUCE 替代原来的DO语句进行简略的循环计算处理括号里面的FOR类似JAVA的FOR语句

INTI X = 0 UNTIL X < 10 THEN X = X + 1 NEXT X = X *10

MESH TABLE

一个具有结构化的内表簇

MESH TABLE的定义需要建立结构中的所有内表的主键关联关系，该关系可以指向自身

在MESHTABLE中 当你访问任意某个节点时，可以使用新的内表表达式ITAB[  Using Key comp1 = ? ]

(note 新的内表表达式内部的筛选类似Read Table所以依然无法使用模糊判断)

这个跟普通的表没有区别



当你需要依赖它的链路关系的时候会体现该表类型的优势

举例，原来如果想要通过销售订单取交货单再取销售发票再取发票会计凭证，会经历非常多的表关系递进

并且语句会显得很长。需要重复Readtable，可读性差

通过MESHTABLE可以再任意节点访问其他节点的数据

MESHTABLE-NODE1\\_NODE2[ MESHTABLE-NODE1[ Using Key comp1 = ? ]  node2comp1 = ?  ]

这样就可以只需要在仅仅获取到NODE1相关信息的情况下得到NODE2的数据

而且还可以反向寻找

MESHTABLE-NODE2\\^_NODE1[ MESHTABLE-NODE2[ node2comp1 = ?  ]  ]

这样就可以通过下级节点的信息方便的反向找到上级节点

例子中涉及到的节点流比较短，在长节点流中可以更明显体现他的优势和语法的整洁性

自洽的内表

类似HR_STRUC_GET函数的返回值中，获取到的组织架构信息内表自身体现了上级节点和下级节点的关系

像这样的内表可以定义一个MESHTABLE NODE1 Association NODE1 on NODE1-ID = NODE1-PARENT

于是就可以通过任意一个上级节点找到以它为上级的下级节点

MESHTABLE-NODE1\\_NODE1[ MESHTABLE-NODE1[ Using Key ID = 1]  ]

具有较大优势的是下面的语法

MESHTABLE-NODE1\\_NODE1+[ MESHTABLE-NODE1[ Using Key ID = 1]  ]

这个+号表示向下完全展开这样极大节省了开发时间

或者

MESHTABLE-NODE1\\_NODE1*[ MESHTABLE-NODE1[ Using Key ID = 1]  ]

这里的*号依然有向下展开的效果，但是它同时还要求当前节点存在上级节点，并在结果中取出那一层的数据

