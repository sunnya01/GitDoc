## 多线程

###### 多线程实现方式

1.继承Thread类重写run方法 2.实现Runnable接口实现run方法3.实现Callable接口实现call方法

区分: 

1 比较基础略过

2 将多线程需要执行的逻辑进行独立的类包装，与方法1不同的是，可以将该类的实例对象进行多次线程的启动，

3 通过泛型，可以将动态的设置返回类型，在多线程的线程对象绑定启动后，并在后续通过FuturTask的实例对象进行处理结果读取

###### 多线程的安全机制

1. synchronized(Object obj){  } 同步代码块,本质通过任何对象的的父类Object的未知锁属性，某个线程进入时对改对象的堆空间的该属性进行赋值，其他线程进入如果发型该属性存在值，则进行堵塞

2. synchronized void method(){} 同步方法，与同步代码块本质是一样的，只不过同步方法如果是静态方法，则对本类的静态锁属性进行判断，如果是实例方法则对调用该方法的当前实例对象也就是this对象进行锁属性的判断，值得一提的是如果是同步方法的形式，则当前类中的所有同步方法共享一个锁，也就是A线程进入了该类的s1同步方法，则B线程如果想要执行该类的s2同步方法也需要等待，应为他们都是基于当前类的锁属性实现同步的

3. lock接口，通过ReentrantLock的实例对象，它本质实现了lock接口(该锁定原理依然是同上基于实例对象或者静态类的锁属性实现)，在方法内可以自由的使用lock对象.lock();方法进行锁定，或者.unlock();方法解锁能够更好在一个方法内动态的结合具体逻辑进行加锁解锁比较推荐的保证线程安全的方法

   

###### 多线程安全机制下的死锁以及sleep(),wait()的区分

死锁造成的原因，对同一个同步代码块进行不同线程的操作时，如果涉及到对多个对象的锁定访问则会有可能造成互锁的问题

例：1线程在他的异步方法体内执行A逻辑需要锁定obj1对象，执行完A逻辑后再执行B逻辑，B逻辑需要锁定obj2对象

2线程在他的异步方法体内执行C逻辑需要锁定obj2对象，执行完C逻辑后再执行B逻辑，D逻辑需要锁定obj1对象,则有概率会发生

1线程执行完A逻辑时，由于在等待被2线程C逻辑锁定的obj2对象时发生堵塞，导致它对obj1一直占用，从而影响2线程的D逻辑需要对obj1锁定是一直无法继续

因此双发在互相等待中发生死锁

Sleep()是挂靠在object类中的方法，可以在任意地方使用，表示的是当前线程挂起，但是如果是同步区的代码sleep也不会放开当前代码块的控制权

wait()方法表示的是当前线程挂起，该方法也是object类中的方法，必须依靠一个同步块中的锁定对象，不然会报异常。当该方法执行完以后当前线程的同步区代码开始挂起，并推出锁定，允许其他线程进入该同步代码块。并且允许在其他线程调用object的notify的方法唤醒当前线程进行对后续逻辑的完成



###### 线程池

Executors 工厂类 主要用户返回实现了ExecutorService接口的实现类的实例对象，后续对需要进行多线程执行的代码都是通过该接口的实例对象完成

ExecutorService接口，通过实现了Runnable接口的实例对象，改对象内部的run方法包含了具体待执行的逻辑，结合ExecutorService接口的方法的

execute方法作为实参填入，线程池自动分配资源。或者通过实现了Callable接口的实例对象调用ExecutorService的submit方法作为实参填入

###### 线程池-ExecutorService接口的多种实现方式

Executor工厂提供了多种方法返回不同的线程池管理对象

Executors.*newCachedThreadPool*() 新增一个动态数量的线程池,即当你使用返回的ExecutorService接口实例对象调用execute方法或者submit方法时内部会自动创建线程，改线程执行完毕后会保留固定时间，超过时间未被使用后关闭。该方法允许填入一个Thread对象作为每次创建新线程的代理对象(通过ThreadFactory接口包装一层)通常会在接口待实现的newThread方法中使用new Thread(Runnable)再包一层创建Thread对象并返回，并基于这个对象设置线程的相关属性，Runnable表示的是外部调用execute方法或者submit方法传入的待执行逻辑实例对象，也可以在新的Thread对象中重写run方法，并在里面调用Runnable的run方法实现代理

Executors.*newSingleThreadExecutor*()新增一个只包含一个线程的线程池

Executors.newFixedThreadPool(int count) 新增一个包含了count个线程的线程池

Executors.newScheduledThreadPool(int count) 新增一个包含了count个线程的线程池，该线程池对象继承了ScheduledExecutorService接口，此接口提供了线程执行的一些按照延迟固定时间执行方法或者按照周期性计划执行方法

ThreadPoolExecutor Executors工厂类返回的接口实例对象本质上是实现了ExecutorService接口的ThreadPoolExecutor类的实例对象，因此也可以对返回的接口实例对象进行向下强转 ThreadPoolExecutor executorService1 = (ThreadPoolExecutor) Executors.*newFixedThreadPool*(10);并通过该类的结构的实例对象进行<u>线程池</u>属性的设置，即线程池的管理
