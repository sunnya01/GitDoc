#### 枚举&泛型&注解

##### 枚举

JDK5之前通过定义一个私有构造方法的类，里面定义静态实例对象创建一个枚举类

JDK5之后通过关键字enum创建，1. 不允许公开的构造方法 2.静态实例对象必须在开头使用objec1(构造方法-可选),object2,object3;的形式连续声明

本质上enum关键字是在新建一个类A，并使该类默认继承于Enum类。类A可以拥有于其他类几乎一样的功能例如实现接口。

##### 泛型

<?>泛型通配符,与<T>不同的是T表示的是形参,?表示的是实惨，本质意义 对于创建泛型类实例对象时表示创建一个包含任意泛型类型参数的引用变量，这个引用变量对象不能够执行任何操作内部涉及到泛型的属性，只能够用来保存其给了具体泛型类型的泛型类的实例对象地址

对于参数则表示该参数可以兼容泛型类的带任意泛型参数的实例对象例如method(ArrayList<?> arrays)

<E extends class<E>> 这种型式的泛型表达式，表示这个泛型类型参数传入的实参只能是他的子类，且该子类继承的泛型父类必须为SubClass extend Class<SubClass>这也就意味着当你创建Class的第一个子类时他继承父类的泛型参数只能是他本身，而其他子类在继承父类时可以选择这个第一个类也可以继续填写自己本身，这种继承时给入的泛型参数为本身的就是符合表达式要求的，而那些不填入自身子类类型，而是填写了其他符合要求的子类类型，编译时涉及到父类的使用过泛型参数的地方，编译器会认识是那个符合要求的子类进行判断

*<u><? extends Class></u>*

*<u><? super Class></u>*

<u>*<u>这两个与前面定义时添加的泛型声明式效果刚好相反，前面提到了?代表的是实参，因此<? extends Class>表示的是这里的实例对象可能是任何类Class的子类，因此输入时给任何类都不满足，返回时可以用任意Class类或者他父类的实例对象接收，<? super Class>则是该实例对象的所有类型都是他的父类，因此输入时可以提供Class或者他的任意子类，返回时任意类都都不能作为接收对象，基于以上特性<? extends Class>*通常用在返回参数的类型限制，<? super Class>通常用在输入参数的类型限制</u>*</u>

泛型的本质是加强了编译时对代码的类型校验

这种泛型表达式在枚举类中Enum可以看见，当你自定义一个枚举类时他就继承了Enum类并且泛型参数就是当前子类，如果你用该自定义枚举类的实例对象进行父类Enum方法的调用时，这些方法中的参数的类型就是Enum类的泛型参数也就是子类本身，这样避免了不同子类对象调用某些方法时比如比较方法，会存在子类之间的比较。他比上限下限的泛型定义更加严格，要求泛型参数只能是继承了父类且给父类泛型参数传自身的类，能够在父类的参数中含有泛型的同时，还限制了子类型的一致性

泛型方法public <T,E> void method( T t ){  };泛型方法的泛型参数独立于类的泛型参数且优先级高于同名的类泛型参数，方法的泛型参数必须通过形参绑定给入，例如前面的例子，方法声明了泛型参数T和E，形参中使用了T，那么当调用方法给入实参关联到T以后，T就有了类型，而E则没有传入且无法传入，E = Object

##### 注解

注解的本质，去中心化根据配置执行通用性统一代码，原来如果需要进行一些框架的搭建，我们会默认一些约定俗成的条目来限制操作对象和需要执行的框架逻辑的关系，或者创建一些配置表来统一维护这些关系然后确保框架代码与被执行对象的关联正确性。注解则改变了这一策略，框架代码内部只关心与各种注解交互。然后在开发对象中自动给自己添加这种关系声明，然后通过反射被读取。

@Target(Class)//Target元注解的一种,用来解释其他注解的注解称为元注解，Class是元注解Target的参数，表示该注解可以出现在类定义中

@Retention(RetentionPolicy.**RUNTIME**)//Retention元注解的一种，表示注解存在的生命周期，RUNTIME表示运行时该注解依然存在

@Inherited//Inherited元注解的一种，表示当前注解被使用时，使用类的子类也会自动继承该注解

@interface Annotations{

String value();//String 参数类型 value 参数名称

}

使用

@Annotations( value = "测试注解" )

Class ClassName{

}
